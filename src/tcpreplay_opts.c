/*   -*- buffer-read-only: t -*- vi: set ro:
 *  
 *  DO NOT EDIT THIS FILE   (tcpreplay_opts.c)
 *  
 *  It has been AutoGen-ed  March 24, 2010 at 05:49:14 PM by AutoGen 5.9.9
 *  From the definitions    tcpreplay_opts.def
 *  and the template file   options
 *
 * Generated from AutoOpts 32:2:7 templates.
 */

/*
 *  This file was produced by an AutoOpts template.  AutoOpts is a
 *  copyrighted work.  This source file is not encumbered by AutoOpts
 *  licensing, but is provided under the licensing terms chosen by the
 *  tcpreplay author or copyright holder.  AutoOpts is licensed under
 *  the terms of the LGPL.  The redistributable library (``libopts'') is
 *  licensed under the terms of either the LGPL or, at the users discretion,
 *  the BSD license.  See the AutoOpts and/or libopts sources for details.
 *
 * This source file is copyrighted and licensed under the following terms:
 *
 * tcpreplay copyright (c) 2000-2008 Aaron Turner - all rights reserved
 *
 * tcpreplay is free software copyrighted by Aaron Turner.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name ``Aaron Turner'' nor the name of any other
 *    contributor may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 * 
 * tcpreplay IS PROVIDED BY Aaron Turner ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Aaron Turner OR ANY OTHER CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
extern FILE * option_usage_fp;
#define OPTION_CODE_COMPILE 1
#include "tcpreplay_opts.h"

#ifdef  __cplusplus
extern "C" {
#endif

/* TRANSLATORS: choose the translation for option names wisely because you
                cannot ever change your mind. */
tSCC zCopyright[] =
       "tcpreplay copyright (c) 2000-2008 Aaron Turner, all rights reserved";
tSCC zCopyrightNotice[1458] =
"tcpreplay is free software copyrighted by Aaron Turner.\n\n\
Redistribution and use in source and binary forms, with or without\n\
modification, are permitted provided that the following conditions are met: 1.\n\
Redistributions of source code must retain the above copyright notice, this\n\
list of conditions and the following disclaimer.  2.  Redistributions in binary\n\
form must reproduce the above copyright notice, this list of conditions and the\n\
following disclaimer in the documentation and/or other materials provided with\n\
the distribution.  3.  Neither the name ``Aaron Turner'' nor the name of any\n\
other contributor may be used to endorse or promote products derived from this\n\
software without specific prior written permission.\n\n\
tcpreplay IS PROVIDED BY Aaron Turner ``AS IS'' AND ANY EXPRESS OR IMPLIED\n\
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n\
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n\
EVENT SHALL Aaron Turner OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n\
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n\
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n\
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n\
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n\
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.";

extern tUsageProc optionUsage;

/*
 *  global included definitions
 */
#include "defines.h"
#include "tcpreplay.h"
#include "common.h"
#include "config.h"
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>


#ifndef NULL
#  define NULL 0
#endif
#ifndef EXIT_SUCCESS
#  define  EXIT_SUCCESS 0
#endif
#ifndef EXIT_FAILURE
#  define  EXIT_FAILURE 1
#endif
/*
 *  Dbug option description:
 */
#ifdef DEBUG
tSCC    zDbugText[] =
        "Enable debugging output";
tSCC    zDbug_NAME[]               = "DBUG";
tSCC    zDbug_Name[]               = "dbug";
#define zDbugDefaultArg              ((char const*)0)
#define DBUG_FLAGS       (OPTST_DISABLED | OPTST_IMM \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

#else   /* disable Dbug */
#define VALUE_OPT_DBUG NO_EQUIVALENT
#define DBUG_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zDbugDefaultArg NULL
#define zDbugText       NULL
#define zDbug_NAME      NULL
#define zDbug_Name      NULL
#endif  /* DEBUG */

/*
 *  Quiet option description:
 */
tSCC    zQuietText[] =
        "Quiet mode";
tSCC    zQuiet_NAME[]              = "QUIET";
tSCC    zQuiet_Name[]              = "quiet";
#define QUIET_FLAGS       (OPTST_DISABLED)

/*
 *  Timer option description:
 */
tSCC    zTimerText[] =
        "Select packet timing mode: select, ioport, rdtsc, gtod, nano, abstime";
tSCC    zTimer_NAME[]              = "TIMER";
tSCC    zTimer_Name[]              = "timer";
tSCC    zTimerDefaultArg[]           = "gtod";
#define TIMER_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Sleep_Accel option description:
 */
tSCC    zSleep_AccelText[] =
        "Reduce the amount of time to sleep by specified usec";
tSCC    zSleep_Accel_NAME[]        = "SLEEP_ACCEL";
tSCC    zSleep_Accel_Name[]        = "sleep-accel";
#define zSleep_AccelDefaultArg       ((char const*)0)
#define SLEEP_ACCEL_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Rdtsc_Clicks option description:
 */
tSCC    zRdtsc_ClicksText[] =
        "Specify the RDTSC clicks/usec";
tSCC    zRdtsc_Clicks_NAME[]       = "RDTSC_CLICKS";
tSCC    zRdtsc_Clicks_Name[]       = "rdtsc-clicks";
#define zRdtsc_ClicksDefaultArg      ((char const*)0)
#define RDTSC_CLICKS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Verbose option description:
 */
#ifdef ENABLE_VERBOSE
tSCC    zVerboseText[] =
        "Print decoded packets via tcpdump to STDOUT";
tSCC    zVerbose_NAME[]            = "VERBOSE";
tSCC    zVerbose_Name[]            = "verbose";
#define VERBOSE_FLAGS       (OPTST_DISABLED | OPTST_IMM)

#else   /* disable Verbose */
#define VALUE_OPT_VERBOSE NO_EQUIVALENT
#define VERBOSE_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zVerboseText       NULL
#define zVerbose_NAME      NULL
#define zVerbose_Name      NULL
#endif  /* ENABLE_VERBOSE */

/*
 *  Decode option description with
 *  "Must also have options" and "Incompatible options":
 */
#ifdef ENABLE_VERBOSE
tSCC    zDecodeText[] =
        "Arguments passed to tcpdump decoder";
tSCC    zDecode_NAME[]             = "DECODE";
tSCC    zDecode_Name[]             = "decode";
static const int
    aDecodeMustList[] = {
    INDEX_OPT_VERBOSE, NO_EQUIVALENT };
#define DECODE_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

#else   /* disable Decode */
#define VALUE_OPT_DECODE NO_EQUIVALENT
#define DECODE_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define aDecodeMustList   NULL
#define zDecodeText       NULL
#define zDecode_NAME      NULL
#define zDecode_Name      NULL
#endif  /* ENABLE_VERBOSE */

/*
 *  Enable_File_Cache option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zEnable_File_CacheText[] =
        "Enable caching of packets to internal memory";
tSCC    zEnable_File_Cache_NAME[]  = "ENABLE_FILE_CACHE";
tSCC    zEnable_File_Cache_Name[]  = "enable-file-cache";
static const int
    aEnable_File_CacheMustList[] = {
    INDEX_OPT_LOOP, NO_EQUIVALENT };
#define ENABLE_FILE_CACHE_FLAGS       (OPTST_DISABLED)

/*
 *  Preload_Pcap option description:
 */
tSCC    zPreload_PcapText[] =
        "Preloads packets into RAM before sending";
tSCC    zPreload_Pcap_NAME[]       = "PRELOAD_PCAP";
tSCC    zPreload_Pcap_Name[]       = "preload-pcap";
#define PRELOAD_PCAP_FLAGS       (OPTST_DISABLED)

/*
 *  Cachefile option description:
 */
tSCC    zCachefileText[] =
        "Split traffic via a tcpprep cache file";
tSCC    zCachefile_NAME[]          = "CACHEFILE";
tSCC    zCachefile_Name[]          = "cachefile";
#define CACHEFILE_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Intf1 option description:
 */
tSCC    zIntf1Text[] =
        "Server/primary traffic output interface";
tSCC    zIntf1_NAME[]              = "INTF1";
tSCC    zIntf1_Name[]              = "intf1";
#define INTF1_FLAGS       (OPTST_DISABLED | OPTST_MUST_SET \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Intf2 option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zIntf2Text[] =
        "Client/secondary traffic output interface";
tSCC    zIntf2_NAME[]              = "INTF2";
tSCC    zIntf2_Name[]              = "intf2";
static const int
    aIntf2MustList[] = {
    INDEX_OPT_CACHEFILE, NO_EQUIVALENT };
#define INTF2_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Listnics option description:
 */
#ifdef ENABLE_PCAP_FINDALLDEVS
tSCC    zListnicsText[] =
        "List available network interfaces and exit";
tSCC    zListnics_NAME[]           = "LISTNICS";
tSCC    zListnics_Name[]           = "listnics";
#define LISTNICS_FLAGS       (OPTST_DISABLED | OPTST_IMM)

#else   /* disable Listnics */
#define VALUE_OPT_LISTNICS NO_EQUIVALENT
#define LISTNICS_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zListnicsText       NULL
#define zListnics_NAME      NULL
#define zListnics_Name      NULL
#endif  /* ENABLE_PCAP_FINDALLDEVS */

/*
 *  Loop option description:
 */
tSCC    zLoopText[] =
        "Loop through the capture file X times";
tSCC    zLoop_NAME[]               = "LOOP";
tSCC    zLoop_Name[]               = "loop";
#define zLoopDefaultArg              ((char const*)1)
#define LOOP_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Pktlen option description:
 */
tSCC    zPktlenText[] =
        "Override the snaplen and use the actual packet len";
tSCC    zPktlen_NAME[]             = "PKTLEN";
tSCC    zPktlen_Name[]             = "pktlen";
#define PKTLEN_FLAGS       (OPTST_DISABLED)

/*
 *  Limit option description:
 */
tSCC    zLimitText[] =
        "Limit the number of packets to send";
tSCC    zLimit_NAME[]              = "LIMIT";
tSCC    zLimit_Name[]              = "limit";
#define zLimitDefaultArg             ((char const*)-1)
#define LIMIT_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Multiplier option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zMultiplierText[] =
        "Modify replay speed to a given multiple";
tSCC    zMultiplier_NAME[]         = "MULTIPLIER";
tSCC    zMultiplier_Name[]         = "multiplier";
static const int
    aMultiplierCantList[] = {
    INDEX_OPT_PPS,
    INDEX_OPT_MBPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define MULTIPLIER_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Pps option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zPpsText[] =
        "Replay packets at a given packets/sec";
tSCC    zPps_NAME[]                = "PPS";
tSCC    zPps_Name[]                = "pps";
static const int
    aPpsCantList[] = {
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_MBPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define PPS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Mbps option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zMbpsText[] =
        "Replay packets at a given Mbps";
tSCC    zMbps_NAME[]               = "MBPS";
tSCC    zMbps_Name[]               = "mbps";
static const int
    aMbpsCantList[] = {
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_PPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define MBPS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Topspeed option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zTopspeedText[] =
        "Replay packets as fast as possible";
tSCC    zTopspeed_NAME[]           = "TOPSPEED";
tSCC    zTopspeed_Name[]           = "topspeed";
static const int
    aTopspeedCantList[] = {
    INDEX_OPT_MBPS,
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_PPS,
    INDEX_OPT_ONEATATIME, NO_EQUIVALENT };
#define TOPSPEED_FLAGS       (OPTST_DISABLED)

/*
 *  Oneatatime option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zOneatatimeText[] =
        "Replay one packet at a time for each user input";
tSCC    zOneatatime_NAME[]         = "ONEATATIME";
tSCC    zOneatatime_Name[]         = "oneatatime";
static const int
    aOneatatimeCantList[] = {
    INDEX_OPT_MBPS,
    INDEX_OPT_PPS,
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define ONEATATIME_FLAGS       (OPTST_DISABLED)

/*
 *  Pps_Multi option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zPps_MultiText[] =
        "Number of packets to send for each time interval";
tSCC    zPps_Multi_NAME[]          = "PPS_MULTI";
tSCC    zPps_Multi_Name[]          = "pps-multi";
#define zPps_MultiDefaultArg         ((char const*)1)
static const int
    aPps_MultiMustList[] = {
    INDEX_OPT_PPS, NO_EQUIVALENT };
#define PPS_MULTI_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Pid option description:
 */
tSCC    zPidText[] =
        "Print the PID of tcpreplay at startup";
tSCC    zPid_NAME[]                = "PID";
tSCC    zPid_Name[]                = "pid";
#define PID_FLAGS       (OPTST_DISABLED)

/*
 *  Version option description:
 */
tSCC    zVersionText[] =
        "Print version information";
tSCC    zVersion_NAME[]            = "VERSION";
tSCC    zVersion_Name[]            = "version";
#define VERSION_FLAGS       (OPTST_DISABLED)

/*
 *  Less_Help option description:
 */
tSCC    zLess_HelpText[] =
        "Display less usage information and exit";
tSCC    zLess_Help_NAME[]          = "LESS_HELP";
tSCC    zLess_Help_Name[]          = "less-help";
#define LESS_HELP_FLAGS       (OPTST_DISABLED | OPTST_IMM)

/*
 *  Help/More_Help option descriptions:
 */
tSCC zHelpText[]          = "Display usage information and exit";
tSCC zHelp_Name[]         = "help";
tSCC zMore_HelpText[]     = "Extended usage information passed thru pager";
tSCC zMore_Help_Name[]    = "more-help";
tSCC zSave_OptsText[]     = "Save the option state to a config file";
tSCC zSave_Opts_Name[]    = "save-opts";
tSCC zLoad_OptsText[]     = "Load options from a config file";
tSCC zLoad_Opts_NAME[]    = "LOAD_OPTS";
tSCC zNotLoad_Opts_Name[] = "no-load-opts";
tSCC zNotLoad_Opts_Pfx[]  = "no";
#define zLoad_Opts_Name   (zNotLoad_Opts_Name + 3)
/*
 *  Declare option callback procedures
 */
#ifdef DEBUG
  static tOptProc doOptDbug;
#else /* not DEBUG */
# define doOptDbug NULL
#endif /* def/not DEBUG */
#ifdef ENABLE_PCAP_FINDALLDEVS
  static tOptProc doOptListnics;
#else /* not ENABLE_PCAP_FINDALLDEVS */
# define doOptListnics NULL
#endif /* def/not ENABLE_PCAP_FINDALLDEVS */
extern tOptProc
    optionNumericVal, optionPagedUsage;
static tOptProc
    doOptLess_Help, doOptLimit,     doOptLoop,      doOptPid,
    doOptPps_Multi, doOptVersion,   doUsageOpt;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the Tcpreplay Option Descriptions.
 */
static tOptDesc optDesc[ OPTION_CT ] = {
  {  /* entry idx, value */ 0, VALUE_OPT_DBUG,
     /* equiv idx, value */ 0, VALUE_OPT_DBUG,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DBUG_FLAGS, 0,
     /* last opt argumnt */ { zDbugDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptDbug,
     /* desc, NAME, name */ zDbugText, zDbug_NAME, zDbug_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 1, VALUE_OPT_QUIET,
     /* equiv idx, value */ 1, VALUE_OPT_QUIET,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ QUIET_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zQuietText, zQuiet_NAME, zQuiet_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 2, VALUE_OPT_TIMER,
     /* equiv idx, value */ 2, VALUE_OPT_TIMER,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TIMER_FLAGS, 0,
     /* last opt argumnt */ { zTimerDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zTimerText, zTimer_NAME, zTimer_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 3, VALUE_OPT_SLEEP_ACCEL,
     /* equiv idx, value */ 3, VALUE_OPT_SLEEP_ACCEL,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SLEEP_ACCEL_FLAGS, 0,
     /* last opt argumnt */ { zSleep_AccelDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zSleep_AccelText, zSleep_Accel_NAME, zSleep_Accel_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 4, VALUE_OPT_RDTSC_CLICKS,
     /* equiv idx, value */ 4, VALUE_OPT_RDTSC_CLICKS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ RDTSC_CLICKS_FLAGS, 0,
     /* last opt argumnt */ { zRdtsc_ClicksDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zRdtsc_ClicksText, zRdtsc_Clicks_NAME, zRdtsc_Clicks_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 5, VALUE_OPT_VERBOSE,
     /* equiv idx, value */ 5, VALUE_OPT_VERBOSE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERBOSE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zVerboseText, zVerbose_NAME, zVerbose_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 6, VALUE_OPT_DECODE,
     /* equiv idx, value */ 6, VALUE_OPT_DECODE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DECODE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aDecodeMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zDecodeText, zDecode_NAME, zDecode_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 7, VALUE_OPT_ENABLE_FILE_CACHE,
     /* equiv idx, value */ 7, VALUE_OPT_ENABLE_FILE_CACHE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENABLE_FILE_CACHE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aEnable_File_CacheMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zEnable_File_CacheText, zEnable_File_Cache_NAME, zEnable_File_Cache_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 8, VALUE_OPT_PRELOAD_PCAP,
     /* equiv idx, value */ 8, VALUE_OPT_PRELOAD_PCAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PRELOAD_PCAP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zPreload_PcapText, zPreload_Pcap_NAME, zPreload_Pcap_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 9, VALUE_OPT_CACHEFILE,
     /* equiv idx, value */ 9, VALUE_OPT_CACHEFILE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ CACHEFILE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zCachefileText, zCachefile_NAME, zCachefile_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 10, VALUE_OPT_INTF1,
     /* equiv idx, value */ 10, VALUE_OPT_INTF1,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 1, 1, 0,
     /* opt state flags  */ INTF1_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zIntf1Text, zIntf1_NAME, zIntf1_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 11, VALUE_OPT_INTF2,
     /* equiv idx, value */ 11, VALUE_OPT_INTF2,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ INTF2_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aIntf2MustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zIntf2Text, zIntf2_NAME, zIntf2_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 12, VALUE_OPT_LISTNICS,
     /* equiv idx, value */ 12, VALUE_OPT_LISTNICS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LISTNICS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptListnics,
     /* desc, NAME, name */ zListnicsText, zListnics_NAME, zListnics_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 13, VALUE_OPT_LOOP,
     /* equiv idx, value */ 13, VALUE_OPT_LOOP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOOP_FLAGS, 0,
     /* last opt argumnt */ { zLoopDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLoop,
     /* desc, NAME, name */ zLoopText, zLoop_NAME, zLoop_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 14, VALUE_OPT_PKTLEN,
     /* equiv idx, value */ 14, VALUE_OPT_PKTLEN,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PKTLEN_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zPktlenText, zPktlen_NAME, zPktlen_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 15, VALUE_OPT_LIMIT,
     /* equiv idx, value */ 15, VALUE_OPT_LIMIT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LIMIT_FLAGS, 0,
     /* last opt argumnt */ { zLimitDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLimit,
     /* desc, NAME, name */ zLimitText, zLimit_NAME, zLimit_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 16, VALUE_OPT_MULTIPLIER,
     /* equiv idx, value */ 16, VALUE_OPT_MULTIPLIER,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MULTIPLIER_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aMultiplierCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zMultiplierText, zMultiplier_NAME, zMultiplier_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 17, VALUE_OPT_PPS,
     /* equiv idx, value */ 17, VALUE_OPT_PPS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PPS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aPpsCantList,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zPpsText, zPps_NAME, zPps_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 18, VALUE_OPT_MBPS,
     /* equiv idx, value */ 18, VALUE_OPT_MBPS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MBPS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aMbpsCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zMbpsText, zMbps_NAME, zMbps_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 19, VALUE_OPT_TOPSPEED,
     /* equiv idx, value */ 19, VALUE_OPT_TOPSPEED,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TOPSPEED_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aTopspeedCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zTopspeedText, zTopspeed_NAME, zTopspeed_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 20, VALUE_OPT_ONEATATIME,
     /* equiv idx, value */ 20, VALUE_OPT_ONEATATIME,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ONEATATIME_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aOneatatimeCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zOneatatimeText, zOneatatime_NAME, zOneatatime_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 21, VALUE_OPT_PPS_MULTI,
     /* equiv idx, value */ 21, VALUE_OPT_PPS_MULTI,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PPS_MULTI_FLAGS, 0,
     /* last opt argumnt */ { zPps_MultiDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aPps_MultiMustList, NULL,
     /* option proc      */ doOptPps_Multi,
     /* desc, NAME, name */ zPps_MultiText, zPps_Multi_NAME, zPps_Multi_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 22, VALUE_OPT_PID,
     /* equiv idx, value */ 22, VALUE_OPT_PID,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PID_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptPid,
     /* desc, NAME, name */ zPidText, zPid_NAME, zPid_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 23, VALUE_OPT_VERSION,
     /* equiv idx, value */ 23, VALUE_OPT_VERSION,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERSION_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptVersion,
     /* desc, NAME, name */ zVersionText, zVersion_NAME, zVersion_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 24, VALUE_OPT_LESS_HELP,
     /* equiv idx, value */ 24, VALUE_OPT_LESS_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LESS_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLess_Help,
     /* desc, NAME, name */ zLess_HelpText, zLess_Help_NAME, zLess_Help_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_HELP, VALUE_OPT_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doUsageOpt,
     /* desc, NAME, name */ zHelpText, NULL, zHelp_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_MORE_HELP, VALUE_OPT_MORE_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ optionPagedUsage,
     /* desc, NAME, name */ zMore_HelpText, NULL, zMore_Help_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_SAVE_OPTS, VALUE_OPT_SAVE_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
                          | OPTST_ARG_OPTIONAL | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zSave_OptsText, NULL, zSave_Opts_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_LOAD_OPTS, VALUE_OPT_LOAD_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
			  | OPTST_DISABLE_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionLoadOpt,
     /* desc, NAME, name */ zLoad_OptsText, zLoad_Opts_NAME, zLoad_Opts_Name,
     /* disablement strs */ zNotLoad_Opts_Name, zNotLoad_Opts_Pfx }
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the Tcpreplay Option Environment
 */
tSCC   zPROGNAME[]   = "TCPREPLAY";
tSCC   zUsageTitle[] =
"tcpreplay (tcpreplay) - Replay network traffic stored in pcap files\n\
USAGE:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... <pcap_file(s)>\n";
tSCC   zRcName[]     = ".tcpreplayrc";
tSCC*  apzHomeList[] = {
       "$$/",
       NULL };

#define zBugsAddr NULL
tSCC   zExplain[]     = "\n\
tcpreplay is a tool for replaying network traffic from files saved with\n\
tcpdump or other tools which write pcap(3) files.\n";
tSCC    zDetail[]     = "\n\
The basic operation of tcpreplay is to resend  all  packets  from  the\n\
input file(s) at the speed at which they were recorded, or a specified \n\
data rate, up to as fast as the hardware is capable.\n\n\
Optionally, the traffic can be split between two interfaces, written to\n\
files, filtered and edited in various ways, providing the means to test\n\
firewalls, NIDS and other network devices.\n\n\
For more details, please see the Tcpreplay Manual at:\n\
http://tcpreplay.synfin.net/trac/wiki/manual\n";
#define zFullVersion    NULL
/* extracted from /usr/local/share/autogen/optcode.tpl near line 501 */

#if defined(ENABLE_NLS)
# define OPTPROC_BASE OPTPROC_TRANSLATE
  static tOptionXlateProc translate_option_strings;
#else
# define OPTPROC_BASE OPTPROC_NONE
# define translate_option_strings NULL
#endif /* ENABLE_NLS */


#define tcpreplay_full_usage NULL
#define tcpreplay_short_usage NULL
tOptions tcpreplayOptions = {
    OPTIONS_STRUCT_VERSION,
    0, NULL,                    /* original argc + argv    */
    ( OPTPROC_BASE
    + OPTPROC_ERRSTOP
    + OPTPROC_SHORTOPT
    + OPTPROC_LONGOPT
    + OPTPROC_NO_REQ_OPT
    + OPTPROC_ARGS_REQ
    + OPTPROC_GNUUSAGE ),
    0, NULL,                    /* current option index, current option */
    NULL,         NULL,         zPROGNAME,
    zRcName,      zCopyright,   zCopyrightNotice,
    zFullVersion, apzHomeList,  zUsageTitle,
    zExplain,     zDetail,      optDesc,
    zBugsAddr,                  /* address to send bugs to */
    NULL, NULL,                 /* extensions/saved state  */
    optionUsage,       /* usage procedure */
    translate_option_strings,   /* translation procedure */
    /*
     *  Indexes to special options
     */
    { INDEX_OPT_MORE_HELP, /* more-help option index */
      INDEX_OPT_SAVE_OPTS, /* save option index */
      NO_EQUIVALENT, /* '-#' option index */
      NO_EQUIVALENT /* index of default opt */
    },
    29 /* full option count */, 25 /* user option count */,
    tcpreplay_full_usage, tcpreplay_short_usage,
    NULL, NULL
};

/*
 *  Create the static procedure(s) declared above.
 */
static void
doUsageOpt(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    (void)pOptions;
    USAGE( EXIT_SUCCESS );
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the dbug option, when DEBUG is #define-d.
 */
#ifdef DEBUG
static void
doOptDbug(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 0, 5 } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}
#endif /* defined DEBUG */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the listnics option, when ENABLE_PCAP_FINDALLDEVS is #define-d.
 */
#ifdef ENABLE_PCAP_FINDALLDEVS
static void
doOptListnics(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 266 */

    interface_list_t *list = get_interface_list();
    list_interfaces(list);
    free(list);
    exit(0);

}
#endif /* defined ENABLE_PCAP_FINDALLDEVS */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the loop option.
 */
static void
doOptLoop(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 0, LONG_MAX } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the limit option.
 */
static void
doOptLimit(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 1, LONG_MAX } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the pps-multi option.
 */
static void
doOptPps_Multi(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 1, LONG_MAX } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the pid option.
 */
static void
doOptPid(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 416 */

    fprintf(stderr, "PID: %hu\n", getpid());

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the version option.
 */
static void
doOptVersion(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 428 */

    fprintf(stderr, "tcpreplay version: %s (build %s)", VERSION, svn_version());
#ifdef DEBUG
    fprintf(stderr, " (debug)");
#endif
    fprintf(stderr, "\n");
    fprintf(stderr, "Copyright 2001-2009 by Aaron Turner <aturner at synfin dot net>\n");
    fprintf(stderr, "Cache file supported: %s\n", CACHEVERSION);
#ifdef HAVE_LIBDNET
    fprintf(stderr, "Compiled against libdnet: %s\n", LIBDNET_VERSION);
#else
    fprintf(stderr, "Not compiled with libdnet.\n");
#endif
#ifdef HAVE_WINPCAP
    fprintf(stderr, "Compiled against winpcap: %s\n", get_pcap_version());
#else
    fprintf(stderr, "Compiled against libpcap: %s\n", get_pcap_version());
#endif
#ifdef ENABLE_64BITS
    fprintf(stderr, "64 bit packet counters: enabled\n");
#else
    fprintf(stderr, "64 bit packet counters: disabled\n");
#endif
#ifdef ENABLE_VERBOSE
    fprintf(stderr, "Verbose printing via tcpdump: enabled\n");
#else
    fprintf(stderr, "Verbose printing via tcpdump: disabled\n");
#endif
#ifdef TCPREPLAY_EDIT
    fprintf(stderr, "Packet editing: enabled\n");
#else
    fprintf(stderr, "Packet editing: disabled\n");
#endif
#ifdef ENABLE_FRAGROUTE
    fprintf(stderr, "Fragroute engine: enabled\n");
#else
    fprintf(stderr, "Fragroute engine: disabled\n");
#endif
    fprintf(stderr, "Injection method: %s\n", sendpacket_get_method());
    exit(0);

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the less-help option.
 */
static void
doOptLess_Help(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 479 */

    USAGE(EXIT_FAILURE);

}
/* extracted from /usr/local/share/autogen/optcode.tpl near line 633 */

#if ENABLE_NLS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <autoopts/usage-txt.h>

static char* AO_gettext( char const* pz );
static void  coerce_it(void** s);

static char*
AO_gettext( char const* pz )
{
    char* pzRes;
    if (pz == NULL)
        return NULL;
    pzRes = _(pz);
    if (pzRes == pz)
        return pzRes;
    pzRes = strdup( pzRes );
    if (pzRes == NULL) {
        fputs( _("No memory for duping translated strings\n"), stderr );
        exit( EXIT_FAILURE );
    }
    return pzRes;
}

static void coerce_it(void** s) { *s = AO_gettext(*s); }
#define COERSION(_f) \
  coerce_it((void*)&(tcpreplayOptions._f))

/*
 *  This invokes the translation code (e.g. gettext(3)).
 */
static void
translate_option_strings( void )
{
    /*
     *  Guard against re-translation.  It won't work.  The strings will have
     *  been changed by the first pass through this code.  One shot only.
     */
    if (option_usage_text.field_ct != 0) {

        /*
         *  Do the translations.  The first pointer follows the field count
         *  field.  The field count field is the size of a pointer.
         */
        tOptDesc* pOD = tcpreplayOptions.pOptDesc;
        char**    ppz = (char**)(void*)&(option_usage_text);
        int       ix  = option_usage_text.field_ct;

        do {
            ppz++;
            *ppz = AO_gettext(*ppz);
        } while (--ix > 0);

        COERSION(pzCopyright);
        COERSION(pzCopyNotice);
        COERSION(pzFullVersion);
        COERSION(pzUsageTitle);
        COERSION(pzExplain);
        COERSION(pzDetail);
        option_usage_text.field_ct = 0;

        for (ix = tcpreplayOptions.optCt; ix > 0; ix--, pOD++)
            coerce_it((void*)&(pOD->pzText));
    }

    if ((tcpreplayOptions.fOptSet & OPTPROC_NXLAT_OPT_CFG) == 0) {
        tOptDesc* pOD = tcpreplayOptions.pOptDesc;
        int       ix;

        for (ix = tcpreplayOptions.optCt; ix > 0; ix--, pOD++) {
            coerce_it((void*)&(pOD->pz_Name));
            coerce_it((void*)&(pOD->pz_DisableName));
            coerce_it((void*)&(pOD->pz_DisablePfx));
        }
        /* prevent re-translation */
        tcpreplayOptions.fOptSet |= OPTPROC_NXLAT_OPT_CFG | OPTPROC_NXLAT_OPT;
    }
}

#endif /* ENABLE_NLS */

#ifdef  __cplusplus
}
#endif
/* tcpreplay_opts.c ends here */
