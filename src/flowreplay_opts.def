autogen definitions options;


copyright = {
    date        = "2004-2007";
    owner       = "Aaron Turner";
    type        = "bsd";
    author      = <<- EOText
Copyright 2000-2007 Aaron Turner

For support please use the tcpreplay-users@lists.sourceforge.net mailing list.

The latest version of this software is always available from:
http://tcpreplay.synfin.net/
EOText;
};

package         = "flowreplay";
prog-name       = "flowreplay";
prog-title      = "Connect to servers based on network traffic stored in pcap files";
long-opts;
gnu-usage;
help-value      = "H";
save-opts-value = "";
load-opts-value = "";
argument = "<pcap_file(s)>";


config-header   = "config.h";

include         = "#include \"defines.h\"\n"
                "#include \"flowreplay.h\"\n"
                "#include \"common.h\"\n"
                "#include \"config.h\"\n"
                "extern flowreplay_opt_t options;\n";

homerc          = "$$/";

explain = <<- EOExplain
flowreplay is a tool for using network traffic stored in pcap(3) files as
the basis for replaying connections to servers.
EOExplain;

detail = <<- EODetail
Please note that flowreplay is currently in *alpha*.  As such, it is still
very much a work in progress and currently will not work for most uses.  If
you have the skill and interest to help make flowreplay work better, please
contact Aaron Turner.

For more details, please see the Tcpreplay Manual at:
http://tcpreplay.synfin.net/trac/wiki/manual
EODetail;

flag = {
    ifdef       = DEBUG;
    name        = dbug;
    value       = d;
    arg-type    = number;
    max         = 1;
    immediate;
    arg-range   = "0->5";
    arg-default = 0;
    descrip     = "Enable debugging output";
    doc         = <<- EOText
If configured with --enable-debug, then you can specify a verbosity 
level for debugging output.  Higher numbers increase verbosity.
EOText;
};

/* Verbose decoding via tcpdump */

flag = {
    ifdef       = ENABLE_VERBOSE;
    name        = verbose;
    value       = v;
    max         = 1;
    immediate;
    descrip     = "Print decoded packets via tcpdump to STDOUT";
    settable;
    doc         = "";
};

flag = {
    ifdef       = ENABLE_VERBOSE;
    name        = decode;
    flags-must  = verbose;
    value       = A;
    arg-type    = string;
    max         = 1;
    descrip     = "Arguments passed to tcpdump decoder";
    doc         = <<- EOText
When enabling verbose mode (@var{-v}) you may also specify one or more
additional  arguments to pass to @code{tcpdump} to modify the way packets
are decoded.  By default, -n and -l are used.   Be  sure  to
quote the arguments like: -A "-axxx" so that they are not interpreted
by tcpreplay.  The following arguments are vaild:
    [ -aAeNqRStuvxX ]
    [ -E spi@ipaddr algo:secret,... ]
    [ -s snaplen ]
EOText;
};


flag = {
    name        = mode;
    value       = m;
    arg-type    = string;
    max         = 1;
    must-set;
    descrip     = "Replay mode";
    doc         = <<- EOText
Flowreplay needs to know handle client/server exchanges to properly time.
The options are:
@table @bullet
@item @var{send}
Replay traffic as fast as possible.  Do not wait for server to reply.
@item @var{wait}
Wait @var{--wait} sec.usec for the server to reply before sending.
@item @var{bytes}
Wait until the server has sent the number of bytes stored in the pcap file.
@item @var{user}
Send packets based on user interaction.
@end table
EOText;
	flag-code	= <<- EOText

	if (strcasecmp(OPT_ARG(MODE), "send") == 0) {
		options.sendmode = MODE_SEND;
	} else if (strcasecmp(OPT_ARG(MODE), "wait") == 0) {
		options.sendmode = MODE_WAIT;
	} else if (strcasecmp(OPT_ARG(MODE), "bytes") == 0) {
		options.sendmode = MODE_BYTES;
	} else if (strcasecmp(OPT_ARG(MODE), "user") == 0) {
		options.sendmode = MODE_USER;
	} else {
		errx(1, "Invalid --mode: %s", OPT_ARG(MODE));
	}

EOText;
};
    
flag = {
    name        = wait;
    value       = w;
    arg-type    = string;
    max         = 1;
    default     = "2.0";
    descrip     = "Number of sec.usec to wait between client's turn to send";
    doc         = <<- EOText
If @var{--mode} is @var{wait}, then you can specify the amount of time to 
wait for the server to complete it's side of the transaction before starting
to send the client side again.
EOText;
	flag-code	= <<- EOText

	float2timer(atof(OPT_ARG(WAIT)), &options.timeout);

EOText;
};

flag = {
	name		= targetip;
	value		= t;
	arg-type	= string;
	max			= 1;
	must-set;
	descrip		= "Target host to connect to";
	flag-code	= <<- EOText

#ifdef INET_ATON
	if (inet_aton(OPT_ARG(TARGETIP), &options.targetaddr) == 0)
		errx(1, "Invalid target IP address: %s", OPT_ARG(TARGETIP));
#else
	if ((options.targetaddr.s_addr = inet_addr(OPT_ARG(TARGETIP))) == -1)
		errx(1, "Invalid target IP address: %s", OPT_ARG(TARGETIP));
#endif

EOText;
};



flag = {
    name        = filter;
    value       = f;
    arg-type    = string;
    max         = 1;
    descrip     = "BPF filter to limit which flows are replayed";
    doc         = "";
};

flag = {
	name 		= clientnet;
	value		= c;
	arg-type	= string;
	descrip		= "Client network(s)";
	flag-code	= <<- EOText
  
    char *cidr = safe_strdup(OPT_ARG(CLIENTNET));
    if (!parse_cidr(&options.clients, cidr, ","))
        errx(1, "Unable to parse CIDR: %s", OPT_ARG(CLIENTNET));
    free(cidr);

EOText;
};


flag = {
	name		= servernet;
	value		= s;
	arg-type	= string;
	descrip		= "Server network(s)";
	flag-code	= <<- EOText

	char *cidr = safe_strdup(OPT_ARG(SERVERNET));
	if (!parse_cidr(&options.servers, cidr, ","))
		errx(1, "Unable to parse CIDR: %s", OPT_ARG(SERVERNET));
	free(cidr);

EOText;
};

flag = {
	name		= nosyn;
	value		= n;
	descrip		= "Disable Syn packet requirement to start connections";
	flag-code	= <<- EOText

options.nosyn = 1;

EOText;
};

flag = {
	name		= slimit;
	value		= l;
	descrip		= "Service limit to proto/port";
	arg-type	= string;
	flag-code	= <<- EOText

	char *p_parse = NULL, *myarg;
	myarg = safe_strdup(OPT_ARG(SLIMIT));

	p_parse = strtok(myarg, "/");
	if (strcasecmp(p_parse, "TCP") == 0) {
		options.proto = IPPROTO_TCP;
	} else if (strcasecmp(p_parse, "UDP") == 0) {
		options.proto = IPPROTO_UDP;
	} else {
		errx(1, "Unsupported protocol: %s", p_parse);
	}

	/* if port is specified, set it */
	if ((p_parse = strtok(NULL, "/")))
		options.port = htons(atoi(p_parse));
	
EOText;
};

flag = {
    name        = version;
    value       = V;
    descrip     = "Print version information";
    flag-code   = <<- EOVersion
    
    fprintf(stderr, "flowreplay version: %s (build %s)", VERSION, svn_version());
#ifdef DEBUG
    fprintf(stderr, " (debug)");
#endif
    fprintf(stderr, "\n");
    fprintf(stderr, "Copyright 2001-2007 by Aaron Turner <aturner at synfin dot net>\n");
#ifdef HAVE_LIBNET
    fprintf(stderr, "Compiled against libnet: %s\n", LIBNET_VERSION);
#else
	fprintf(stderr, "Not compiled with libnet.\n");
#endif
#ifdef HAVE_WINPCAP
	fprintf(stderr, "Compiled against winpcap: %s\n", get_pcap_version());
#else
    fprintf(stderr, "Compiled against libpcap: %s\n", get_pcap_version());
#endif
#ifdef ENABLE_64BITS
    fprintf(stderr, "64 bit packet counters: enabled\n");
#else
    fprintf(stderr, "64 bit packet counters: disabled\n");
#endif
#ifdef ENABLE_VERBOSE
    fprintf(stderr, "Verbose printing via tcpdump: enabled\n");
#else
    fprintf(stderr, "Verbose printing via tcpdump: disabled\n");
#endif
    exit(0);
    
EOVersion;
    doc         = "";
};

flag = {
    name        = less-help;
    value       = "h";
    immediate;
    descrip     = "Display less usage information and exit";
    flag-code   = <<- EOHelp
  
    USAGE(EXIT_FAILURE);

EOHelp;
    doc         = "";
};
