autogen definitions options;

copyright = {
    date        = "2004";
    owner       = "Aaron Turner";
    eaddr       = "aturner@pobox.com";
    type        = "bsd";
};

package         = "tcprewrite";
prog-name       = "tcprewrite";
prog-title      = "Rewrite the packets in a pcap file.";
long-opts;
gnu-usage;
help-value      = "H";
save-opts-value = "";
load-opts-value = "";

config-header   = "config.h";
include         = "#include \"defines.h\"\n"
                "#include \"common.h\"\n"
                "#include \"tcprewrite.h\"\n"
                "extern char pcap_version[];\n"
                "extern tcprewrite_opt_t options;\n";


flag = {
    name        = dbug;
    value       = d;
    arg-type    = number;
    descrip     = "Enable debugging output";
    max         = 1;
    immediate;
};

flag = {
    name        = seed;
    value       = s;
    arg-type    = number;
    descrip     = "Randomize src/dst IP addresses w/ given seed";
    max         = 1;
    flag-code   = <<- EOSeed
  
    options.rewrite_ip ++;
    options.seed = atoi(OPT_ARG(SEED));

EOSeed;
};

flag = {
    name        = dmac;
    value       = D;
    arg-type    = string;
    max         = 1;
    descrip     = "Rewrite destination MAC addresses";
    flag-code   = <<- EODmac
    
    dualmac2hex(OPT_ARG(DMAC), options.intf1_dmac, options.intf2_dmac,
        strlen(OPT_ARG(DMAC)));

EODmac;
};

flag = {
    name        = smac;
    value       = S;
    arg-type    = string;
    max         = 1;
    descrip     = "Rewrite source MAC addresses";
    flag-code   = <<- EOSmac
    
    dualmac2hex(OPT_ARG(SMAC), options.intf1_smac, options.intf2_smac,
        strlen(OPT_ARG(SMAC)));

EOSmac;
};

flag = {
    name        = pnat;
    value       = N;
    arg-type    = string;
    max         = 2;
    descrip     = "Rewrite IP addresses using pseudo-NAT";
    flag-code   = <<- EOPnat
    
    static int count = 1;

    options.rewrite_ip ++;
    
    if (count == 1) {
        if (! parse_cidr_map(&options.cidrmap1, OPT_ARG(PNAT)))
            errx(1, "Unable to parse primary pseudo-NAT: %s", OPT_ARG(PNAT));
        count ++;
    } else {
        if (! parse_cidr_map(&options.cidrmap2, OPT_ARG(PNAT)))
            errx(1, "Unable parse secondary pseudo-NAT: %s", OPT_ARG(PNAT));
    }

EOPnat;
};

flag = {
    name        = dlink;
    value       = l;
    arg-type    = string;
    max         = 2;
    descrip     = "Rewrite Data-Link layer with specified data";
    flag-code   = <<- EODlink

    static int count = 1;
    
    options.l2.enabled = 1;
    
    if (count == 1) {
        options.l2.len = read_hexstring(OPT_ARG(DLINK), options.l2.data1, L2DATALEN);
        count ++;
    } else {
        if (options.l2.len != read_hexstring(OPT_ARG(DLINK), options.l2.data2, L2DATALEN))
            err(1, "Layer2 data for both interfaces must be the same length");
    }

EODlink;
};

flag = {
    name        = fixcsum;
    value       = C;
    disable;
    descrip     = "Force recalculation of IP/TCP/UDP checksums";
    flag-code   = <<- EOFixcsum
  
    options.fixcsum = 1;

EOFixcsum;
};

flag = {
    name        = infile;
    value       = i;
    arg-type    = string;
    descrip     = "Input pcap file";
    max         = 1;
    immediate;
    flag-code   = <<- EOInfile
    
    char ebuf[PCAP_ERRBUF_SIZE];
    options.infile = safe_strdup(OPT_ARG(INFILE));
    if ((options.pin = pcap_open_offline(options.infile, ebuf)) == NULL)
        errx(1, "Unable to open input pcap file: %s", ebuf);

EOInfile;
};

flag = {
    name        = outfile;
    value       = o;
    arg-type    = string;
    descrip     = "Output pcap file";
    max         = 1;
    flag-code   = <<- EOOutfile
  
    options.outfile = safe_strdup(OPT_ARG(OUTFILE));
    if ((options.pout = pcap_dump_open(options.pin, options.outfile)) == NULL)
        errx(1, "Unable to open output pcap file: %s", pcap_geterr(options.pin));

EOOutfile;
};

flag = {
    name        = cachefile;
    value       = c;
    arg-type    = string;
    max         = 1;
    descrip     = "Split traffic via tcpprep cache file";
    settable;
    flag-code   = <<- EOCachefile
    
    options.cache_packets = 
        read_cache(&options.cachedata, OPT_ARG(CACHEFILE), &options.comment);

EOCachefile;    
};

flag = {
    name        = endpoints;
    value       = e;
    arg-type    = string;
    max         = 1;
    descrip     = "Rewrite IP addresses so all traffic is between two endpoints";
    flag-code   = <<- EOEndpoints
    
    options.rewrite_ip ++;
    if (!parse_endpoints(&options.cidrmap1, &options.cidrmap2, OPT_ARG(ENDPOINTS)))
        errx(1, "Unable to parse endpoints: %s", OPT_ARG(ENDPOINTS));
    
EOEndpoints;
};

flag = {
    name        = mtu;
    value       = m;
    arg-type    = number;
    max         = 1;
    arg-range   = "1->MAXPACKET";
    default     = DEFAULT_MTU;
    descrip     = "Override default MTU length (1500 bytes)";
};

flag = {
    name        = efcs;
    value       = E;
    descrip     = "Remove Ethernet checksums (FCS) from end of frames";
    flag-code   = <<- EOEfcs
    
    options.efcs = 1;

EOEfcs;
};

flag = {
    name        = fixlen;
    value       = F;
    descrip     = "Pad or truncate packet data to match header length";
    max         = 1;
    arg-type    = string;
    flag-code   = <<- EOFixlen

    if (strcmp(OPT_ARG(FIXLEN), "pad") == 0) {
        options.fixlen = FIXLEN_PAD;
    } else if (strcmp(OPT_ARG(FIXLEN), "trunc") == 0) {
        options.fixlen = FIXLEN_TRUNC;
    } else {
        errx(1, "Invalid fixlen argument '%s'.  Must be 'trunc' or 'pad'", OPT_ARG(FIXLEN));
    }

EOFixlen;
};

/* rewrite 802.1q vlan tags */
flag = {
    name        = vlan;
    value       = l;
    max         = 1;
    descrip     = "Specify 802.1q VLAN tag mode: del, add or edit";
    arg-type    = string;
    flag-code   = <<- EOVlan

    if (strcmp(OPT_ARG(VLAN), "add") == 0) {
        options.vlan = VLAN_ADD;
    } else if (strcmp(OPT_ARG(VLAN), "del") == 0) {
        options.vlan = VLAN_DEL;
    } else if (strcmp(OPT_ARG(VLAN), "edit") == 0) {
        options.vlan = VLAN_EDIT;
    } else {
        errx(1, "Invalid vlan argument '%s'.  Must be 'add', 'del' or 'edit'", OPT_ARG(VLAN));
    }

EOVlan;
};

flag = {
    name        = vlan_tag;
    value       = t;
    max         = 1;
    descrip     = "Specify the new 802.1q VLAN tag value";
    arg-type    = number;
    arg-range   = "1->65535";
};

/* Verbose decoding via tcpdump */

flag = {
    ifdef       = HAVE_TCPDUMP;
    name        = verbose;
    value       = v;
    max         = 1;
    immediate;
    descrip     = "Print decoded packets via tcpdump to STDOUT";
    settable;
};

flag = {
    ifdef       = HAVE_TCPDUMP;
    name        = decode;
    flags-must  = verbose;
    value       = A;
    arg-type    = string;
    max         = 1;
    descrip     = "Arguments passed to tcpdump decoder";
};


flag = {
    name        = version;
    value       = V;
    descrip     = "Print version information";
    flag-code   = <<- EOVersion
    
    fprintf(stderr, "tcprewrite version: %s (build %s)", VERSION, svn_version());
#ifdef DEBUG
    fprintf(stderr, " (debug)");
#endif
    fprintf(stderr, "\n");
    fprintf(stderr, "Cache file supported: %s\n", CACHEVERSION);
    fprintf(stderr, "Compiled against libnet: %s\n", LIBNET_VERSION);
    fprintf(stderr, "Compiled against libpcap: %s\n", pcap_version);
#ifdef ENABLE_64BIT
    fprintf(stderr, "64 bit packet counters: enabled\n");
#else
    fprintf(stderr, "64 bit packet counters: disabled\n");
#endif
    exit(0);
    
EOVersion;
};

flag = {
    name        = less-help;
    value       = h;
    immediate;
    descrip     = "Display less usage information and exit";
    flag-code   = <<- EOHelp
  
    USAGE(EXIT_FAILURE);

EOHelp;
};
