$Id: flowreplay.txt,v 1.3 2003/06/10 05:19:29 aturner Exp $

---------------------------------------------------------------------------
Ideas
---------------------------------------------------------------------------
	- Socket based solution rather then processing raw packets with
	libpcap and sending via libnet.

	- Rather then opening the pcap file multiple times, or fseek/rewind'ing
	all around the file to jump between current flows, better to buffer
	packets to be sent.  With a few MB buffer limit, we shouldn't create
	a blocking condition for most cases.  (Also, no need to buffer S->C 
	packets, just keep track of bytes sent as we already do.)

	- Rather then use a semi-unique key for the RB tree, use a 12 byte
	string represening the 4-tuple of the flow.  Use the semi-unique
	key for dbg() purposes, since 0's in the string will be treated as NULL.
	Collisions won't be a problem, and our RB tree should never grow too big.

	- How many threads do we need?  We should be able to put the read pcap
	into a single thread and wrap the select() for send/reading off the wire
	into another.  It might be doable in a single thread.

	- Knowing when to start sending client traffic in response to the server
	will be "tricky".  Prolly the best bet is waiting for a given period of
	time after no more data from the server has been recieved.  Basing on
	number of bytes is prolly less then ideal.  Not sure what to do if the
	client traffic doesn't illicit a response from the server.

	- We'll prolly need a 'clean up thread' to go through the flow tree's
	and close stalled flows and free up their send buffers.  Knowing when
	to do this and what flows to close will be important.
	
	- Dealing with waiting on multiple flows will be tricky.  Finding a
	portable way to determine how much time remained before select()
	returned in the case of a ready file descriptor will be less then
	fun.

	- Have a plugin architecture which allows protocol decoders to be
	written which replace the lame generic timing methods we'll have
	to use to know when to send client data.

	- Should we support server sockets?  This would be to support FTP
	as well as acting as a web server, etc.

	- I can't figure out a way to write the code single threaded and support
	plugins which are smarter then the simple timeout-timer mentioned above.
	Basically, flows supporting plugins would basically require a select() 
	timeout	of either 0 (poll) or NULL (indefinate timeout) which would be
	incompatible with other "stupider" flows.


---------------------------------------------------------------------------
Plugins
---------------------------------------------------------------------------

After a lot of thought, I've come to realize that if I really want to make
flowreplay useful, then having a plugin architecture will be critical. 
Reasons for this are simple:

	1) I'd like flowreplay to work well with a variety of protocols
	2) I'd rather get other people to write code for me when possible
	3) A monolithic code architecture doesn't lead to #1 or #2 being likely

So how should this work?  Well plugins need to be flexible.  I don't know what
protocols people will use plugins for or why they may want to do what they want
to do.  I also want to keep things simple for the common case.  If things are
complicated for complex corner cases, I can live with that.

So basically, a plugin needs to register itself with flowreplay and which
protocols and/or services it should handle.  Only one plugin can be registered 
per protocol or service, although a plugin can register multiple protocols or services.

If no plugin has registered for a protocol or service, then the default plugin
will handle the traffic.

Plugin Basics:

Registering a plugin comprises the following information:
	- IP Protocol (TCP, UDP, etc)
	- Service Port
	- socket handler & timeout
	- pcap handler
	- per-flow data structure (static data specific to a flow)

Addtionally at startup, each plugin must provide:
	- plugin initializer function, which must return a ptr to the
		 plugins global data struct (or NULL for none)
void *plugin_init();

	- plugin shutdown function, which must free that global data struct
void plugin_shutdown(void *global);


The only problem with this, is how do we register a plugin for multi-flow
connections as in the case of FTP?  Well that's simple:

Whenever flowreplay reads a packet off the wire or pcap, it does a flow lookup
in the appropriate IP protocol tree.  In the case of FTP, when the ftp plugin
detects a connection being negotiated to transfer a file, it creates a node 
in the tree for this connection which will then match the subsequent connection.
Since the plugin has control over the node, it can register itself (or another
plugin) as the handler for that connection.

Each plugin must handle two re-occuring events: 
     1) packets being recieved via the network socket:

void socket_handler(struct sessionon_t *node, void *global, 
     u_char *packet, int len);

     This function is called each time a packet is recieved on a flow
     for which the plugin has registered itself for.

     2) packets being read from the pcap file:

u_char *pcap_handler(struct session_t *node, void *global, 
       u_char *packet, int len);

     This function is called everytime a packet is read from the the pcap
     file for which the plugin has registered itself for.


---------------------------------------------------------------------------
Pro's & Con's
---------------------------------------------------------------------------

Sockets:
	- No need to futz with layer 3/4 translation.  Just deal with data.
	- select() should make scaling to 100's of connections painless
	- Unable to maintain source ports or source IP's
	- Unable to replicate Syn with data
	- Unable to replicate specific layer 3/4 data
	- One socket per TCP session, UDP can use socket over and over again
	- Does not require root

Libnet/libpcap:
	- Need to deal with layer 3/4 translation
	- Can maintain source ports and source IP's
	- May get source port conflicts when sending all traffic to a given server
	- Requires using libpcap to read off the wire which isn't
	  as nice as select()
	- Possibly can use select() with libpcap however.  Need to research.
	- Look into the libnet 1.1.1 patch which is supposed to deal with
	  detecting responses to packets sent with libnet.
	- Will I need to deal with funky TCP/IP options?  Should I?
	- One libpcap socket per pcap file?


